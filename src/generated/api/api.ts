/* tslint:disable */
/* eslint-disable */
/**
 * GrowthBook REST API
 * GrowthBook offers a full REST API for interacting with the GrowthBook application. This is currently in **beta** as we add more authenticated API routes and features.  Request data can use either JSON or Form data encoding (with proper `Content-Type` headers). All response bodies are JSON-encoded.  The API base URL for GrowthBook Cloud is `https://api.growthbook.io`. For self-hosted deployments, it is the same as your API_HOST environment variable (defaults to `http://localhost:3100`). The rest of these docs will assume you are using GrowthBook Cloud.  ## Authentication  We support both the HTTP Basic and Bearer authentication schemes for convenience.  You first need to generate a new Secret Key in GrowthBook by going to `Settings -> API Keys`.  If using HTTP Basic auth, pass the Secret Key as the username and leave the password blank:  ```bash curl https://api.growthbook.io/api/v1 \\   -u secret_abc123DEF456: # The \":\" at the end stops curl from asking for a password ```  If using Bearer auth, pass the Secret Key as the token:  ```bash curl https://api.growthbook.io/api/v1 \\ -H \"Authorization: Bearer secret_abc123DEF456\" ```  ## Errors  The API may return the following error status codes:  - **400** - Bad Request - Often due to a missing required parameter - **401** - Unauthorized - No valid API key provided - **402** - Request Failed - The parameters are valid, but the request failed - **403** - Forbidden - Provided API key does not have the required access - **404** - Not Found - Unknown API route or requested resource - **429** - Too Many Requests - You exceeded the rate limit of 60 requests per minute. Try again later. - **5XX** - Server Error - Something went wrong on GrowthBook\'s end (these are rare)  The response body will be a JSON object with the following properties:  - **message** - Information about the error 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'projectIds': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'eventTracker': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'identifierTypes': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'assignmentQueries': any;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'identifierJoinQueries': any;
    /**
     * 
     * @type {DataSourceMixpanelSettings}
     * @memberof DataSource
     */
    'mixpanelSettings'?: DataSourceMixpanelSettings;
}
/**
 * 
 * @export
 * @interface DataSourceMixpanelSettings
 */
export interface DataSourceMixpanelSettings {
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'viewedExperimentEventName': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'experimentIdProperty': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'variationIdProperty': any;
    /**
     * 
     * @type {any}
     * @memberof DataSourceMixpanelSettings
     */
    'extraUserIdProperty': any;
}
/**
 * 
 * @export
 * @interface DeleteSavedGroup200Response
 */
export interface DeleteSavedGroup200Response {
    /**
     * 
     * @type {any}
     * @memberof DeleteSavedGroup200Response
     */
    'deletedId': any;
}
/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'datasourceId': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'identifierType': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Dimension
     */
    'query': any;
}
/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'project': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'hypothesis': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'tags': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'archived': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'status': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'autoRefresh': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'hashAttribute': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'variations': any;
    /**
     * 
     * @type {any}
     * @memberof Experiment
     */
    'phases': any;
    /**
     * 
     * @type {ExperimentAnalysisSettings}
     * @memberof Experiment
     */
    'settings': ExperimentAnalysisSettings;
    /**
     * 
     * @type {ExperimentResultSummary}
     * @memberof Experiment
     */
    'resultSummary'?: ExperimentResultSummary;
}
/**
 * 
 * @export
 * @interface ExperimentAnalysisSettings
 */
export interface ExperimentAnalysisSettings {
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'datasourceId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'assignmentQueryId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'experimentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'segmentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'queryFilter': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'inProgressConversions': ExperimentAnalysisSettingsInProgressConversionsEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'attributionModel': ExperimentAnalysisSettingsAttributionModelEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'statsEngine': ExperimentAnalysisSettingsStatsEngineEnum;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'goals': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentAnalysisSettings
     */
    'guardrails': any;
    /**
     * 
     * @type {ExperimentMetric}
     * @memberof ExperimentAnalysisSettings
     */
    'activationMetric'?: ExperimentMetric;
}

export const ExperimentAnalysisSettingsInProgressConversionsEnum = {
    Include: 'include',
    Exclude: 'exclude'
} as const;

export type ExperimentAnalysisSettingsInProgressConversionsEnum = typeof ExperimentAnalysisSettingsInProgressConversionsEnum[keyof typeof ExperimentAnalysisSettingsInProgressConversionsEnum];
export const ExperimentAnalysisSettingsAttributionModelEnum = {
    FirstExposure: 'firstExposure',
    ExperimentDuration: 'experimentDuration'
} as const;

export type ExperimentAnalysisSettingsAttributionModelEnum = typeof ExperimentAnalysisSettingsAttributionModelEnum[keyof typeof ExperimentAnalysisSettingsAttributionModelEnum];
export const ExperimentAnalysisSettingsStatsEngineEnum = {
    Bayesian: 'bayesian',
    Frequentist: 'frequentist'
} as const;

export type ExperimentAnalysisSettingsStatsEngineEnum = typeof ExperimentAnalysisSettingsStatsEngineEnum[keyof typeof ExperimentAnalysisSettingsStatsEngineEnum];

/**
 * 
 * @export
 * @interface ExperimentMetric
 */
export interface ExperimentMetric {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetric
     */
    'metricId': any;
    /**
     * 
     * @type {ExperimentMetricOverrides}
     * @memberof ExperimentMetric
     */
    'overrides': ExperimentMetricOverrides;
}
/**
 * 
 * @export
 * @interface ExperimentMetricOverrides
 */
export interface ExperimentMetricOverrides {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'conversionWindowStart'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'conversionWindowEnd'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'winRiskThreshold'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetricOverrides
     */
    'loseRiskThreshold'?: any;
}
/**
 * 
 * @export
 * @interface ExperimentResultSummary
 */
export interface ExperimentResultSummary {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'status': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'winner': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'conclusions': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultSummary
     */
    'releasedVariationId': any;
}
/**
 * 
 * @export
 * @interface ExperimentResults
 */
export interface ExperimentResults {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'experimentId': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'phase': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateStart': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'dateEnd': any;
    /**
     * 
     * @type {ExperimentResultsDimension}
     * @memberof ExperimentResults
     */
    'dimension': ExperimentResultsDimension;
    /**
     * 
     * @type {ExperimentAnalysisSettings}
     * @memberof ExperimentResults
     */
    'settings': ExperimentAnalysisSettings;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'queryIds': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResults
     */
    'results': any;
}
/**
 * 
 * @export
 * @interface ExperimentResultsDimension
 */
export interface ExperimentResultsDimension {
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultsDimension
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof ExperimentResultsDimension
     */
    'id'?: any;
}
/**
 * 
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'archived': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'project': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'valueType': FeatureValueTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'defaultValue': any;
    /**
     * 
     * @type {any}
     * @memberof Feature
     */
    'tags': any;
    /**
     * 
     * @type {{ [key: string]: FeatureEnvironment; }}
     * @memberof Feature
     */
    'environments': { [key: string]: FeatureEnvironment; };
    /**
     * 
     * @type {FeatureRevision}
     * @memberof Feature
     */
    'revision': FeatureRevision;
}

export const FeatureValueTypeEnum = {
    Boolean: 'boolean',
    String: 'string',
    Number: 'number',
    Json: 'json'
} as const;

export type FeatureValueTypeEnum = typeof FeatureValueTypeEnum[keyof typeof FeatureValueTypeEnum];

/**
 * 
 * @export
 * @interface FeatureDefinition
 */
export interface FeatureDefinition {
    /**
     * 
     * @type {any}
     * @memberof FeatureDefinition
     */
    'defaultValue': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureDefinition
     */
    'rules'?: any;
}
/**
 * 
 * @export
 * @interface FeatureEnvironment
 */
export interface FeatureEnvironment {
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironment
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironment
     */
    'defaultValue': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironment
     */
    'rules': any;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {any}
     * @memberof FeatureEnvironment
     */
    'definition'?: any;
    /**
     * 
     * @type {FeatureEnvironmentDraft}
     * @memberof FeatureEnvironment
     */
    'draft'?: FeatureEnvironmentDraft;
}
/**
 * 
 * @export
 * @interface FeatureEnvironmentDraft
 */
export interface FeatureEnvironmentDraft {
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironmentDraft
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironmentDraft
     */
    'defaultValue': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureEnvironmentDraft
     */
    'rules': any;
    /**
     * A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)
     * @type {any}
     * @memberof FeatureEnvironmentDraft
     */
    'definition'?: any;
}
/**
 * 
 * @export
 * @interface FeatureExperimentRule
 */
export interface FeatureExperimentRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'trackingKey'?: any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'hashAttribute'?: any;
    /**
     * 
     * @type {FeatureExperimentRuleNamespace}
     * @memberof FeatureExperimentRule
     */
    'namespace'?: FeatureExperimentRuleNamespace;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'coverage'?: any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRule
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface FeatureExperimentRuleNamespace
 */
export interface FeatureExperimentRuleNamespace {
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureExperimentRuleNamespace
     */
    'range': any;
}
/**
 * 
 * @export
 * @interface FeatureForceRule
 */
export interface FeatureForceRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureForceRule
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface FeatureRevision
 */
export interface FeatureRevision {
    /**
     * 
     * @type {any}
     * @memberof FeatureRevision
     */
    'version': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRevision
     */
    'comment': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRevision
     */
    'date': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRevision
     */
    'publishedBy': any;
}
/**
 * 
 * @export
 * @interface FeatureRolloutRule
 */
export interface FeatureRolloutRule {
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'condition': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'enabled': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'type': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'value': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'coverage': any;
    /**
     * 
     * @type {any}
     * @memberof FeatureRolloutRule
     */
    'hashAttribute': any;
}
/**
 * 
 * @export
 * @interface GetDataSource200Response
 */
export interface GetDataSource200Response {
    /**
     * 
     * @type {DataSource}
     * @memberof GetDataSource200Response
     */
    'dataSource': DataSource;
}
/**
 * 
 * @export
 * @interface GetDimension200Response
 */
export interface GetDimension200Response {
    /**
     * 
     * @type {Dimension}
     * @memberof GetDimension200Response
     */
    'dimension': Dimension;
}
/**
 * 
 * @export
 * @interface GetExperiment200Response
 */
export interface GetExperiment200Response {
    /**
     * 
     * @type {Experiment}
     * @memberof GetExperiment200Response
     */
    'experiment': Experiment;
}
/**
 * 
 * @export
 * @interface GetExperimentResults200Response
 */
export interface GetExperimentResults200Response {
    /**
     * 
     * @type {ExperimentResults}
     * @memberof GetExperimentResults200Response
     */
    'result'?: ExperimentResults;
}
/**
 * 
 * @export
 * @interface GetFeature200Response
 */
export interface GetFeature200Response {
    /**
     * 
     * @type {Feature}
     * @memberof GetFeature200Response
     */
    'feature': Feature;
}
/**
 * 
 * @export
 * @interface GetProject200Response
 */
export interface GetProject200Response {
    /**
     * 
     * @type {Project}
     * @memberof GetProject200Response
     */
    'project': Project;
}
/**
 * 
 * @export
 * @interface GetSdkConnection200Response
 */
export interface GetSdkConnection200Response {
    /**
     * 
     * @type {SdkConnection}
     * @memberof GetSdkConnection200Response
     */
    'sdkConnection': SdkConnection;
}
/**
 * 
 * @export
 * @interface GetSegment200Response
 */
export interface GetSegment200Response {
    /**
     * 
     * @type {Segment}
     * @memberof GetSegment200Response
     */
    'segment': Segment;
}
/**
 * 
 * @export
 * @interface GetVisualChangeset200Response
 */
export interface GetVisualChangeset200Response {
    /**
     * 
     * @type {VisualChangeset}
     * @memberof GetVisualChangeset200Response
     */
    'visualChangeset': VisualChangeset;
    /**
     * 
     * @type {Experiment}
     * @memberof GetVisualChangeset200Response
     */
    'experiment'?: Experiment;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'datasourceId': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'description': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'type': MetricTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'tags': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'projects': any;
    /**
     * 
     * @type {any}
     * @memberof Metric
     */
    'archived': any;
    /**
     * 
     * @type {MetricBehavior}
     * @memberof Metric
     */
    'behavior': MetricBehavior;
    /**
     * 
     * @type {MetricSql}
     * @memberof Metric
     */
    'sql'?: MetricSql;
    /**
     * 
     * @type {MetricSqlBuilder}
     * @memberof Metric
     */
    'sqlBuilder'?: MetricSqlBuilder;
    /**
     * 
     * @type {MetricMixpanel}
     * @memberof Metric
     */
    'mixpanel'?: MetricMixpanel;
}

export const MetricTypeEnum = {
    Binomial: 'binomial',
    Count: 'count',
    Duration: 'duration',
    Revenue: 'revenue'
} as const;

export type MetricTypeEnum = typeof MetricTypeEnum[keyof typeof MetricTypeEnum];

/**
 * 
 * @export
 * @interface MetricBehavior
 */
export interface MetricBehavior {
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'goal': MetricBehaviorGoalEnum;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'cap': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'conversionWindowStart': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'conversionWindowEnd': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'riskThresholdSuccess': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'riskThresholdDanger': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'minPercentChange': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'maxPercentChange': any;
    /**
     * 
     * @type {any}
     * @memberof MetricBehavior
     */
    'minSampleSize': any;
}

export const MetricBehaviorGoalEnum = {
    Increase: 'increase',
    Decrease: 'decrease'
} as const;

export type MetricBehaviorGoalEnum = typeof MetricBehaviorGoalEnum[keyof typeof MetricBehaviorGoalEnum];

/**
 * 
 * @export
 * @interface MetricMixpanel
 */
export interface MetricMixpanel {
    /**
     * 
     * @type {any}
     * @memberof MetricMixpanel
     */
    'eventName': any;
    /**
     * 
     * @type {any}
     * @memberof MetricMixpanel
     */
    'eventValue': any;
    /**
     * 
     * @type {any}
     * @memberof MetricMixpanel
     */
    'userAggregation': any;
    /**
     * 
     * @type {any}
     * @memberof MetricMixpanel
     */
    'conditions': any;
}
/**
 * 
 * @export
 * @interface MetricSql
 */
export interface MetricSql {
    /**
     * 
     * @type {any}
     * @memberof MetricSql
     */
    'identifierTypes': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSql
     */
    'conversionSQL': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSql
     */
    'userAggregationSQL': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSql
     */
    'denominatorMetricId': any;
}
/**
 * 
 * @export
 * @interface MetricSqlBuilder
 */
export interface MetricSqlBuilder {
    /**
     * 
     * @type {any}
     * @memberof MetricSqlBuilder
     */
    'identifierTypeColumns': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSqlBuilder
     */
    'tableName': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSqlBuilder
     */
    'valueColumnName': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSqlBuilder
     */
    'timestampColumnName': any;
    /**
     * 
     * @type {any}
     * @memberof MetricSqlBuilder
     */
    'conditions': any;
}
/**
 * 
 * @export
 * @interface PaginationFields
 */
export interface PaginationFields {
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'limit': any;
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'offset': any;
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'count': any;
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'total': any;
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'hasMore': any;
    /**
     * 
     * @type {any}
     * @memberof PaginationFields
     */
    'nextOffset': any;
}
/**
 * 
 * @export
 * @interface PostMetric200Response
 */
export interface PostMetric200Response {
    /**
     * 
     * @type {Metric}
     * @memberof PostMetric200Response
     */
    'metric': Metric;
}
/**
 * 
 * @export
 * @interface PostMetricRequest
 */
export interface PostMetricRequest {
    /**
     * ID for the [DataSource](#tag/DataSource_model)
     * @type {any}
     * @memberof PostMetricRequest
     */
    'datasourceId': any;
    /**
     * Name of the person who owns this metric
     * @type {any}
     * @memberof PostMetricRequest
     */
    'owner'?: any;
    /**
     * Name of the metric
     * @type {any}
     * @memberof PostMetricRequest
     */
    'name': any;
    /**
     * Description of the metric
     * @type {any}
     * @memberof PostMetricRequest
     */
    'description'?: any;
    /**
     * Type of metric. See [Metrics documentation](/app/metrics)
     * @type {any}
     * @memberof PostMetricRequest
     */
    'type': PostMetricRequestTypeEnum;
    /**
     * List of tags
     * @type {any}
     * @memberof PostMetricRequest
     */
    'tags'?: any;
    /**
     * List of project IDs for projects that can access this metric
     * @type {any}
     * @memberof PostMetricRequest
     */
    'projects'?: any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequest
     */
    'archived'?: any;
    /**
     * 
     * @type {PostMetricRequestBehavior}
     * @memberof PostMetricRequest
     */
    'behavior'?: PostMetricRequestBehavior;
    /**
     * 
     * @type {PostMetricRequestSql}
     * @memberof PostMetricRequest
     */
    'sql'?: PostMetricRequestSql;
    /**
     * 
     * @type {PostMetricRequestSqlBuilder}
     * @memberof PostMetricRequest
     */
    'sqlBuilder'?: PostMetricRequestSqlBuilder;
    /**
     * 
     * @type {PostMetricRequestMixpanel}
     * @memberof PostMetricRequest
     */
    'mixpanel'?: PostMetricRequestMixpanel;
}

export const PostMetricRequestTypeEnum = {
    Binomial: 'binomial',
    Count: 'count',
    Duration: 'duration',
    Revenue: 'revenue'
} as const;

export type PostMetricRequestTypeEnum = typeof PostMetricRequestTypeEnum[keyof typeof PostMetricRequestTypeEnum];

/**
 * 
 * @export
 * @interface PostMetricRequestBehavior
 */
export interface PostMetricRequestBehavior {
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'goal'?: PostMetricRequestBehaviorGoalEnum;
    /**
     * This should be non-negative
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'cap'?: any;
    /**
     * The start of a Conversion Window relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'conversionWindowStart'?: any;
    /**
     * The end of a [Conversion Window](/app/metrics#conversion-window) relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics#conversion-delay) + Conversion Window Hours settings in the UI. In other words, if you want a 48 hour window starting after 24 hours, you would set conversionWindowStart to 24 and conversionWindowEnd to 72 (24+48). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'conversionWindowEnd'?: any;
    /**
     * Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'riskThresholdSuccess'?: any;
    /**
     * Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'riskThresholdDanger'?: any;
    /**
     * Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'minPercentChange'?: any;
    /**
     * Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'maxPercentChange'?: any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestBehavior
     */
    'minSampleSize'?: any;
}

export const PostMetricRequestBehaviorGoalEnum = {
    Increase: 'increase',
    Decrease: 'decrease'
} as const;

export type PostMetricRequestBehaviorGoalEnum = typeof PostMetricRequestBehaviorGoalEnum[keyof typeof PostMetricRequestBehaviorGoalEnum];

/**
 * Only use for MixPanel (non-SQL) Data Sources. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestMixpanel
 */
export interface PostMetricRequestMixpanel {
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestMixpanel
     */
    'eventName': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestMixpanel
     */
    'eventValue'?: any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestMixpanel
     */
    'userAggregation': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestMixpanel
     */
    'conditions'?: any;
}
/**
 * Preferred way to define SQL. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestSql
 */
export interface PostMetricRequestSql {
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSql
     */
    'identifierTypes': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSql
     */
    'conversionSQL': any;
    /**
     * Custom user level aggregation for your metric (default: `SUM(value)`)
     * @type {any}
     * @memberof PostMetricRequestSql
     */
    'userAggregationSQL'?: any;
    /**
     * The metric ID for a [denominator metric for funnel and ratio metrics](/app/metrics#denominator-ratio--funnel-metrics)
     * @type {any}
     * @memberof PostMetricRequestSql
     */
    'denominatorMetricId'?: any;
}
/**
 * An alternative way to specify a SQL metric, rather than a full query. Using `sql` is preferred to `sqlBuilder`. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.
 * @export
 * @interface PostMetricRequestSqlBuilder
 */
export interface PostMetricRequestSqlBuilder {
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSqlBuilder
     */
    'identifierTypeColumns': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSqlBuilder
     */
    'tableName': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSqlBuilder
     */
    'valueColumnName'?: any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSqlBuilder
     */
    'timestampColumnName': any;
    /**
     * 
     * @type {any}
     * @memberof PostMetricRequestSqlBuilder
     */
    'conditions'?: any;
}
/**
 * 
 * @export
 * @interface PostSavedGroup200Response
 */
export interface PostSavedGroup200Response {
    /**
     * 
     * @type {SavedGroup}
     * @memberof PostSavedGroup200Response
     */
    'savedGroup': SavedGroup;
}
/**
 * 
 * @export
 * @interface PostSavedGroupRequest
 */
export interface PostSavedGroupRequest {
    /**
     * The display name of the Saved Group
     * @type {any}
     * @memberof PostSavedGroupRequest
     */
    'name': any;
    /**
     * An array of values to target (Ex: a list of userIds).
     * @type {any}
     * @memberof PostSavedGroupRequest
     */
    'values': any;
    /**
     * The parameter you want to target users with. Ex: userId, orgId, ...
     * @type {any}
     * @memberof PostSavedGroupRequest
     */
    'attributeKey': any;
    /**
     * The person or team that owns this Saved Group. If no owner, you can pass an empty string.
     * @type {any}
     * @memberof PostSavedGroupRequest
     */
    'owner'?: any;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'description'?: any;
    /**
     * 
     * @type {ProjectSettings}
     * @memberof Project
     */
    'settings'?: ProjectSettings;
}
/**
 * 
 * @export
 * @interface ProjectSettings
 */
export interface ProjectSettings {
    /**
     * 
     * @type {any}
     * @memberof ProjectSettings
     */
    'statsEngine'?: any;
}
/**
 * 
 * @export
 * @interface PutVisualChangeset200Response
 */
export interface PutVisualChangeset200Response {
    /**
     * 
     * @type {any}
     * @memberof PutVisualChangeset200Response
     */
    'nModified': any;
}
/**
 * 
 * @export
 * @interface SavedGroup
 */
export interface SavedGroup {
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'owner'?: any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'attributeKey': any;
    /**
     * 
     * @type {any}
     * @memberof SavedGroup
     */
    'values': any;
}
/**
 * 
 * @export
 * @interface SdkConnection
 */
export interface SdkConnection {
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'dateUpdated': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'languages': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'environment': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'project': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'encryptPayload': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'encryptionKey': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeVisualExperiments'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeDraftExperiments'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'includeExperimentNames'?: any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'key': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxyEnabled': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxyHost': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'proxySigningKey': any;
    /**
     * 
     * @type {any}
     * @memberof SdkConnection
     */
    'sseEnabled'?: any;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'owner': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'datasourceId': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'identifierType': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'query': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'dateCreated': any;
    /**
     * 
     * @type {any}
     * @memberof Segment
     */
    'dateUpdated': any;
}
/**
 * 
 * @export
 * @interface ToggleFeatureRequest
 */
export interface ToggleFeatureRequest {
    /**
     * 
     * @type {any}
     * @memberof ToggleFeatureRequest
     */
    'reason'?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ToggleFeatureRequest
     */
    'environments': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateSavedGroupRequest
 */
export interface UpdateSavedGroupRequest {
    /**
     * The display name of the Saved Group
     * @type {any}
     * @memberof UpdateSavedGroupRequest
     */
    'name'?: any;
    /**
     * An array of values to target (Ex: a list of userIds).
     * @type {any}
     * @memberof UpdateSavedGroupRequest
     */
    'values'?: any;
    /**
     * The person or team that owns this Saved Group. If no owner, you can pass an empty string.
     * @type {any}
     * @memberof UpdateSavedGroupRequest
     */
    'owner'?: any;
}
/**
 * 
 * @export
 * @interface VisualChange
 */
export interface VisualChange {
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'css'?: any;
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'js'?: any;
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'variation': any;
    /**
     * 
     * @type {any}
     * @memberof VisualChange
     */
    'domMutations'?: any;
}
/**
 * 
 * @export
 * @interface VisualChangeset
 */
export interface VisualChangeset {
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'urlPatterns': any;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'editorUrl': any;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'experiment': any;
    /**
     * 
     * @type {any}
     * @memberof VisualChangeset
     */
    'visualChanges': any;
}

/**
 * DataSourcesApi - axios parameter creator
 * @export
 */
export const DataSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSource: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDataSource', 'id', id)
            const localVarPath = `/data-sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources: async (limit?: any, offset?: any, projectId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSourcesApi - functional programming interface
 * @export
 */
export const DataSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSource(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSource(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSources(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataSources(limit, offset, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataSourcesApi - factory interface
 * @export
 */
export const DataSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataSourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single data source
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSource(id: any, options?: any): AxiosPromise<GetDataSource200Response> {
            return localVarFp.getDataSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all data sources
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources(limit?: any, offset?: any, projectId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listDataSources(limit, offset, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourcesApi - object-oriented interface
 * @export
 * @class DataSourcesApi
 * @extends {BaseAPI}
 */
export class DataSourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get a single data source
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public getDataSource(id: any, options?: AxiosRequestConfig) {
        return DataSourcesApiFp(this.configuration).getDataSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all data sources
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listDataSources(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig) {
        return DataSourcesApiFp(this.configuration).listDataSources(limit, offset, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DimensionsApi - axios parameter creator
 * @export
 */
export const DimensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDimension: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDimension', 'id', id)
            const localVarPath = `/dimensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDimensions: async (limit?: any, offset?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dimensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DimensionsApi - functional programming interface
 * @export
 */
export const DimensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DimensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDimension(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDimension200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDimension(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDimensions(limit, offset, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DimensionsApi - factory interface
 * @export
 */
export const DimensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DimensionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single dimension
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDimension(id: any, options?: any): AxiosPromise<GetDimension200Response> {
            return localVarFp.getDimension(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all dimensions
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listDimensions(limit, offset, datasourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DimensionsApi - object-oriented interface
 * @export
 * @class DimensionsApi
 * @extends {BaseAPI}
 */
export class DimensionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single dimension
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DimensionsApi
     */
    public getDimension(id: any, options?: AxiosRequestConfig) {
        return DimensionsApiFp(this.configuration).getDimension(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all dimensions
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DimensionsApi
     */
    public listDimensions(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return DimensionsApiFp(this.configuration).listDimensions(limit, offset, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExperimentsApi - axios parameter creator
 * @export
 */
export const ExperimentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExperiment', 'id', id)
            const localVarPath = `/experiments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {any} [phase] 
         * @param {any} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults: async (id: any, phase?: any, dimension?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExperimentResults', 'id', id)
            const localVarPath = `/experiments/{id}/results`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (phase !== undefined) {
                localVarQueryParameter['phase'] = phase;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {any} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments: async (limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experiments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }

            if (experimentId !== undefined) {
                localVarQueryParameter['experimentId'] = experimentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperimentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiment(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExperiment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {any} [phase] 
         * @param {any} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentResults(id: any, phase?: any, dimension?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExperimentResults200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentResults(id, phase, dimension, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {any} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiments(limit, offset, projectId, datasourceId, experimentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperimentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single experiment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(id: any, options?: any): AxiosPromise<GetExperiment200Response> {
            return localVarFp.getExperiment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get results for an experiment
         * @param {any} id The id of the requested resource
         * @param {any} [phase] 
         * @param {any} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults(id: any, phase?: any, dimension?: any, options?: any): AxiosPromise<GetExperimentResults200Response> {
            return localVarFp.getExperimentResults(id, phase, dimension, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all experiments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {any} [experimentId] Filter the returned list by the experiment tracking key (id)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listExperiments(limit, offset, projectId, datasourceId, experimentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class ExperimentsApi
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single experiment
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperiment(id: any, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).getExperiment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get results for an experiment
     * @param {any} id The id of the requested resource
     * @param {any} [phase] 
     * @param {any} [dimension] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentResults(id: any, phase?: any, dimension?: any, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).getExperimentResults(id, phase, dimension, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all experiments
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {any} [datasourceId] Filter by Data Source
     * @param {any} [experimentId] Filter the returned list by the experiment tracking key (id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public listExperiments(limit?: any, offset?: any, projectId?: any, datasourceId?: any, experimentId?: any, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).listExperiments(limit, offset, projectId, datasourceId, experimentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeaturesApi - axios parameter creator
 * @export
 */
export const FeaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFeature', 'id', id)
            const localVarPath = `/features/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatures: async (limit?: any, offset?: any, projectId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature: async (id: any, toggleFeatureRequest: ToggleFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('toggleFeature', 'id', id)
            // verify required parameter 'toggleFeatureRequest' is not null or undefined
            assertParamExists('toggleFeature', 'toggleFeatureRequest', toggleFeatureRequest)
            const localVarPath = `/features/{id}/toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toggleFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeaturesApi - functional programming interface
 * @export
 */
export const FeaturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeaturesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatures(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatures(limit, offset, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeature200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleFeature(id, toggleFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeaturesApi - factory interface
 * @export
 */
export const FeaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeaturesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single feature
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(id: any, options?: any): AxiosPromise<GetFeature200Response> {
            return localVarFp.getFeature(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all features
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatures(limit?: any, offset?: any, projectId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listFeatures(limit, offset, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle a feature in one or more environments
         * @param {any} id The id of the requested resource
         * @param {ToggleFeatureRequest} toggleFeatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: any): AxiosPromise<GetFeature200Response> {
            return localVarFp.toggleFeature(id, toggleFeatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeaturesApi - object-oriented interface
 * @export
 * @class FeaturesApi
 * @extends {BaseAPI}
 */
export class FeaturesApi extends BaseAPI {
    /**
     * 
     * @summary Get a single feature
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public getFeature(id: any, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).getFeature(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all features
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public listFeatures(limit?: any, offset?: any, projectId?: any, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).listFeatures(limit, offset, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle a feature in one or more environments
     * @param {any} id The id of the requested resource
     * @param {ToggleFeatureRequest} toggleFeatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public toggleFeature(id: any, toggleFeatureRequest: ToggleFeatureRequest, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).toggleFeature(id, toggleFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMetric', 'id', id)
            const localVarPath = `/metrics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics: async (limit?: any, offset?: any, projectId?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric: async (postMetricRequest: PostMetricRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postMetricRequest' is not null or undefined
            assertParamExists('postMetric', 'postMetricRequest', postMetricRequest)
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postMetricRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetrics(limit, offset, projectId, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetric(postMetricRequest: PostMetricRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMetric200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetric(postMetricRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single metric
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(id: any, options?: any): AxiosPromise<PostMetric200Response> {
            return localVarFp.getMetric(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all metrics
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listMetrics(limit, offset, projectId, datasourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single metric
         * @param {PostMetricRequest} postMetricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric(postMetricRequest: PostMetricRequest, options?: any): AxiosPromise<PostMetric200Response> {
            return localVarFp.postMetric(postMetricRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single metric
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(id: any, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all metrics
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetrics(limit?: any, offset?: any, projectId?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetrics(limit, offset, projectId, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single metric
     * @param {PostMetricRequest} postMetricRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public postMetric(postMetricRequest: PostMetricRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).postMetric(postMetricRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (limit?: any, offset?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProject200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(limit?: any, offset?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single project
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: any, options?: any): AxiosPromise<GetProject200Response> {
            return localVarFp.getProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(limit?: any, offset?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listProjects(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single project
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(id: any, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(limit?: any, offset?: any, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SavedGroupsApi - axios parameter creator
 * @export
 */
export const SavedGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedGroup: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedGroup', 'id', id)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedGroup: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSavedGroup', 'id', id)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedGroups: async (limit?: any, offset?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedGroup: async (postSavedGroupRequest: PostSavedGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSavedGroupRequest' is not null or undefined
            assertParamExists('postSavedGroup', 'postSavedGroupRequest', postSavedGroupRequest)
            const localVarPath = `/saved-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSavedGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedGroup: async (id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSavedGroup', 'id', id)
            // verify required parameter 'updateSavedGroupRequest' is not null or undefined
            assertParamExists('updateSavedGroup', 'updateSavedGroupRequest', updateSavedGroupRequest)
            const localVarPath = `/saved-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSavedGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedGroupsApi - functional programming interface
 * @export
 */
export const SavedGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedGroup(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedGroup(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedGroups(limit?: any, offset?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedGroups(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSavedGroup(postSavedGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSavedGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSavedGroup(id, updateSavedGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedGroupsApi - factory interface
 * @export
 */
export const SavedGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedGroup(id: any, options?: any): AxiosPromise<DeleteSavedGroup200Response> {
            return localVarFp.deleteSavedGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single saved group
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedGroup(id: any, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.getSavedGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all saved group
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedGroups(limit?: any, offset?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listSavedGroups(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a single saved group
         * @param {PostSavedGroupRequest} postSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.postSavedGroup(postSavedGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partially update a single saved group
         * @param {any} id The id of the requested resource
         * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: any): AxiosPromise<PostSavedGroup200Response> {
            return localVarFp.updateSavedGroup(id, updateSavedGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedGroupsApi - object-oriented interface
 * @export
 * @class SavedGroupsApi
 * @extends {BaseAPI}
 */
export class SavedGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a single saved group
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public deleteSavedGroup(id: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).deleteSavedGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single saved group
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public getSavedGroup(id: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).getSavedGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all saved group
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public listSavedGroups(limit?: any, offset?: any, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).listSavedGroups(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a single saved group
     * @param {PostSavedGroupRequest} postSavedGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public postSavedGroup(postSavedGroupRequest: PostSavedGroupRequest, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).postSavedGroup(postSavedGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partially update a single saved group
     * @param {any} id The id of the requested resource
     * @param {UpdateSavedGroupRequest} updateSavedGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedGroupsApi
     */
    public updateSavedGroup(id: any, updateSavedGroupRequest: UpdateSavedGroupRequest, options?: AxiosRequestConfig) {
        return SavedGroupsApiFp(this.configuration).updateSavedGroup(id, updateSavedGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SdkConnectionsApi - axios parameter creator
 * @export
 */
export const SdkConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdkConnection: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSdkConnection', 'id', id)
            const localVarPath = `/sdk-connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdkConnections: async (limit?: any, offset?: any, projectId?: any, withProxy?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdk-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (withProxy !== undefined) {
                localVarQueryParameter['withProxy'] = withProxy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdkConnectionsApi - functional programming interface
 * @export
 */
export const SdkConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdkConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdkConnection(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSdkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdkConnection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSdkConnections(limit, offset, projectId, withProxy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SdkConnectionsApi - factory interface
 * @export
 */
export const SdkConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdkConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single sdk connection
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdkConnection(id: any, options?: any): AxiosPromise<GetSdkConnection200Response> {
            return localVarFp.getSdkConnection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sdk connections
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [projectId] Filter by project id
         * @param {any} [withProxy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listSdkConnections(limit, offset, projectId, withProxy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdkConnectionsApi - object-oriented interface
 * @export
 * @class SdkConnectionsApi
 * @extends {BaseAPI}
 */
export class SdkConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single sdk connection
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdkConnectionsApi
     */
    public getSdkConnection(id: any, options?: AxiosRequestConfig) {
        return SdkConnectionsApiFp(this.configuration).getSdkConnection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sdk connections
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [projectId] Filter by project id
     * @param {any} [withProxy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdkConnectionsApi
     */
    public listSdkConnections(limit?: any, offset?: any, projectId?: any, withProxy?: any, options?: AxiosRequestConfig) {
        return SdkConnectionsApiFp(this.configuration).listSdkConnections(limit, offset, projectId, withProxy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSegment', 'id', id)
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: async (limit?: any, offset?: any, datasourceId?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasourceId'] = datasourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSegment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSegments(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSegments(limit, offset, datasourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single segment
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(id: any, options?: any): AxiosPromise<GetSegment200Response> {
            return localVarFp.getSegment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all segments
         * @param {any} [limit] The number of items to return
         * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
         * @param {any} [datasourceId] Filter by Data Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSegments(limit?: any, offset?: any, datasourceId?: any, options?: any): AxiosPromise<any> {
            return localVarFp.listSegments(limit, offset, datasourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single segment
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(id: any, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all segments
     * @param {any} [limit] The number of items to return
     * @param {any} [offset] How many items to skip (use in conjunction with limit for pagination)
     * @param {any} [datasourceId] Filter by Data Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public listSegments(limit?: any, offset?: any, datasourceId?: any, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).listSegments(limit, offset, datasourceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VisualChangesetsApi - axios parameter creator
 * @export
 */
export const VisualChangesetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVisualChangeset: async (id: any, includeExperiment?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVisualChangeset', 'id', id)
            const localVarPath = `/visual-changesets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeExperiment !== undefined) {
                localVarQueryParameter['includeExperiment'] = includeExperiment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {any} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisualChangesets: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listVisualChangesets', 'id', id)
            const localVarPath = `/experiments/{id}/visual-changesets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVisualChange: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postVisualChange', 'id', id)
            const localVarPath = `/visual-changesets/{id}/visual-change`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChange: async (id: any, visualChangeId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putVisualChange', 'id', id)
            // verify required parameter 'visualChangeId' is not null or undefined
            assertParamExists('putVisualChange', 'visualChangeId', visualChangeId)
            const localVarPath = `/visual-changesets/{id}/visual-change/{visualChangeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"visualChangeId"}}`, encodeURIComponent(String(visualChangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChangeset: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putVisualChangeset', 'id', id)
            const localVarPath = `/visual-changesets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisualChangesetsApi - functional programming interface
 * @export
 */
export const VisualChangesetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualChangesetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVisualChangeset(id: any, includeExperiment?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVisualChangeset(id, includeExperiment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {any} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVisualChangesets(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVisualChangesets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVisualChange(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVisualChange(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVisualChange(id: any, visualChangeId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVisualChange(id, visualChangeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVisualChangeset(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutVisualChangeset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVisualChangeset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisualChangesetsApi - factory interface
 * @export
 */
export const VisualChangesetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisualChangesetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} [includeExperiment] Include the associated experiment in payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVisualChangeset(id: any, includeExperiment?: any, options?: any): AxiosPromise<GetVisualChangeset200Response> {
            return localVarFp.getVisualChangeset(id, includeExperiment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all visual changesets
         * @param {any} id The experiment id the visual changesets belong to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisualChangesets(id: any, options?: any): AxiosPromise<object> {
            return localVarFp.listVisualChangesets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVisualChange(id: any, options?: any): AxiosPromise<PutVisualChangeset200Response> {
            return localVarFp.postVisualChange(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a visual change for a visual changeset
         * @param {any} id The id of the requested resource
         * @param {any} visualChangeId Specify a specific visual change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChange(id: any, visualChangeId: any, options?: any): AxiosPromise<PutVisualChangeset200Response> {
            return localVarFp.putVisualChange(id, visualChangeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a visual changeset
         * @param {any} id The id of the requested resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVisualChangeset(id: any, options?: any): AxiosPromise<PutVisualChangeset200Response> {
            return localVarFp.putVisualChangeset(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualChangesetsApi - object-oriented interface
 * @export
 * @class VisualChangesetsApi
 * @extends {BaseAPI}
 */
export class VisualChangesetsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single visual changeset
     * @param {any} id The id of the requested resource
     * @param {any} [includeExperiment] Include the associated experiment in payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public getVisualChangeset(id: any, includeExperiment?: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).getVisualChangeset(id, includeExperiment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all visual changesets
     * @param {any} id The experiment id the visual changesets belong to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public listVisualChangesets(id: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).listVisualChangesets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a visual change for a visual changeset
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public postVisualChange(id: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).postVisualChange(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a visual change for a visual changeset
     * @param {any} id The id of the requested resource
     * @param {any} visualChangeId Specify a specific visual change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public putVisualChange(id: any, visualChangeId: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).putVisualChange(id, visualChangeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a visual changeset
     * @param {any} id The id of the requested resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualChangesetsApi
     */
    public putVisualChangeset(id: any, options?: AxiosRequestConfig) {
        return VisualChangesetsApiFp(this.configuration).putVisualChangeset(id, options).then((request) => request(this.axios, this.basePath));
    }
}


